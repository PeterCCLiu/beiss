//
// Created by PL on 2022/8/2.
//
#include "../../pbc/include/pbc.h"
#include "string.h"
#include "setup.h"
#include <openssl/sha.h>

// KGC part starts
char ** ExtractPartialPrivateKey(void * ID){
    unsigned char * hash = malloc(SHA256_DIGEST_LENGTH+1); // bytes, 32. MUST +1! otherwise \0 is lost and strlen() becomes unreliable.
    SHA256(ID, strlen(ID), hash);

//    int hashlen = strlen((char *) hash); // 32
//    printf("Your hash in EPPK is = %s\n", hash);
//    printf("Your hashlen in EPPK is = %d\n", hashlen);

    element_t QA;
    element_init_G1(QA, p);
    element_from_hash(QA, hash, SHA256_DIGEST_LENGTH); // check if replaceable with SHA256_DIGEST_LENGTH

    element_t DA;
    element_init_G1(DA, p);
    element_pow_zn(DA, QA, masterPrivateKey);

    element_printf("Your partial private key QA generated in KGC is = %B\n", QA);
    element_printf("Your partial private key DA generated in KGC is = %B\n", DA);

    free(hash);

    char * QA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(QA_string, ELEMENT_STRING_LENGTH, QA);

    char * DA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(DA_string, ELEMENT_STRING_LENGTH, DA);

//    puts(QA_string);
//    puts(DA_string);

    char ** output = malloc(sizeof(QA_string)+sizeof(DA_string));
    output[0] = QA_string;
    output[1] = DA_string;
    return output;
}

void ExportParams(char ** params){
    // Params are generated by KGC only; it should be exported after initialization.
    // TODO
    // Send RESTFUL HTTP call using CoreHTTP SDK
    // unmarshall and construct pairing using param-ed setup()
    return;
}
// KGC part finish

// IoT device part start

int VerifyPartialPrivateKeyIsCorrect(char ** PartialPrivateKeyParams){

    element_t QA;
    element_init_G1(QA, p);
    element_set_str(QA, PartialPrivateKeyParams[0], 10); // decimal output

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, PartialPrivateKeyParams[1], 10);

//    element_printf("Your QA after transmission in Verify is = %B\n", QA);
//    element_printf("Your DA after transmission in Verify is = %B\n", DA);

    element_t result1, result2;
    element_init_GT(result1, p);
    element_init_GT(result2, p);

    element_pairing(result1, DA, g);
    element_pairing(result2, QA, P0);

    int result = element_cmp(result1, result2);
    printf("Your partial private key verification result is = %d, 0 if Partial Secret is correctly generated\n", result);

    return 0;
}

char * SetSecretValue(){

    // Device creates a pure random secret (depends on nothing) for himself
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t xA;
    element_init_Zr(xA, p);
    element_random(xA);

    char * xA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(xA_string, ELEMENT_STRING_LENGTH, xA);

    element_printf("Your local secret xA first created as = %B\n", xA);
//    puts(xA_string);

    return xA_string;
}

char * SetPrivateKey(char * xA_string, char * DA_string){

    // Device creates his full private key, from his local secret xA and KGC partial private key DA
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t SA;
    element_init_G1(SA, p);

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, DA_string, 10);

    element_t xA;
    element_init_Zr(xA, p);
    element_set_str(xA, xA_string, 10);

//    element_printf("Your DA after transmission in SetPrivateKey() is = %B\n", DA);
//    element_printf("Your xA after transmission in SetPrivateKey() is = %B\n", xA);

    element_pow_zn(SA, DA, xA);

    char * SA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(SA_string, ELEMENT_STRING_LENGTH, SA);

    element_printf("Your device full private key is created locally as SA = %B\n", SA);
//    puts(SA_string);

    return SA_string;
}

char ** SetPublicKey(char * xA_string){

    // Device creates his full public key from his local secret xA
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t xA;
    element_init_Zr(xA, p);
    element_set_str(xA, xA_string, 10);

    char ** DevicePublicKey = malloc(ELEMENT_STRING_LENGTH*2);
    char * XA_string = malloc(ELEMENT_STRING_LENGTH);
    char * YA_string = malloc(ELEMENT_STRING_LENGTH);

    element_t XA, YA;
    element_init_G1(XA, p);
    element_init_G1(YA, p);

    element_pow_zn(XA, g, xA);
    element_pow_zn(YA, P0, xA);

    element_snprint(XA_string, ELEMENT_STRING_LENGTH, XA);
    element_snprint(YA_string, ELEMENT_STRING_LENGTH, YA);

    DevicePublicKey[0] = XA_string;
    DevicePublicKey[1] = YA_string;

//    element_printf("Your XA before transmission is = %B\n", XA);
//    element_printf("Your YA before transmission is = %B\n", YA);
//    puts(XA_string);
//    puts(YA_string);

    element_printf("Your device full public key is created locally as XA = %B\n", XA);
    element_printf("Your device full public key is created locally as YA = %B\n", YA);

    return DevicePublicKey;
}

void RegisterPublicKey(char * PA){
    // marshall to JSON format and send via CoreHTTP of AWS
    return;
}

void RetrieveParams(char ** params){
    // Params are generated by KGC only; device can only retrieve them.
    // Send RESTFUL HTTP call using CoreHTTP SDK
    // unmarshall and construct pairing using param-ed setup()
    return;
}

char ** Sign(char * message, char * SA_string){

    printf("Your message to sign is = |%s|\n", message);
    element_t SA;
    element_init_G1(SA, p);
    element_set_str(SA, SA_string, 10);

    element_t a, aP, r, v;
    element_init_Zr(a, p);
    element_init_GT(r, p);
    element_init_G1(aP, p);

//    element_printf("Your SA is = %B\n", SA);
//    element_printf("Your a is = %B\n", a);

    element_random(a);
    element_pow_zn(aP, g, a);
    element_pairing(r, aP, g);

//    element_printf("Your aP is = %B\n", aP);
//    element_printf("Your r is = %B\n", r);

    char * r_string = malloc(ELEMENT_STRING_LENGTH); // length doesn't matter
    element_snprint(r_string, ELEMENT_STRING_LENGTH, r);

    unsigned char * hash = malloc(SHA256_DIGEST_LENGTH+1);
    unsigned char * hash1 = malloc(SHA256_DIGEST_LENGTH+1);
    unsigned char * hash2 = malloc(SHA256_DIGEST_LENGTH+1);

    memset(hash, 0, SHA256_DIGEST_LENGTH+1);
    memset(hash1, 0, SHA256_DIGEST_LENGTH+1);
    memset(hash2, 0, SHA256_DIGEST_LENGTH+1);

//    int message_strlen =  strlen(message);
//    int r_strlen =  strlen(r_string);
//
//    printf("Your strlen(message) is = %d\n", message_strlen);
//    printf("Your strlen(r_string) is = %d\n", r_strlen);

    SHA256((const unsigned char *) message, strlen(message), hash1);
    SHA256((const unsigned char *) r_string, strlen(r_string), hash2);

//    puts(message);
//    puts(r_string);
//    puts("hash1 is");
//    puts(hash1);
//    puts("hash2 is");
//    puts(hash2);
//
//    printf("Your strlen hash1 is = %d\n", strlen(hash1));
//    printf("Your strlen hash2 is = %d\n", strlen(hash2));
//

    unsigned char * prehash = (unsigned char *) malloc(SHA256_DIGEST_LENGTH*2);
    memset(prehash, 0, SHA256_DIGEST_LENGTH*2);

    strcat((char *)prehash, (char *)hash1);
    strcat((char *)prehash, (char *)hash2);

//    puts("Your prehash after concatentation is: ");
//    puts(prehash);

//    printf("Your strlen of hash is = %lu\n", strlen((char *) hash));
//    printf("Your strlen of prehash is = %lu\n", strlen((char *) prehash));

    SHA256((const unsigned char *) (prehash), strlen((char *) prehash), hash);

//    printf("Your strlen of hash is = %lu\n", strlen((char *) hash));

    int hashlen = strlen((char *) hash);

    element_init_Zr(v, p);
    element_from_hash(v, (const void *)hash, hashlen);

    element_t U, U1, U2;
    element_init_G1(U, p);
    element_init_G1(U1, p);
    element_init_G1(U2, p);

    element_pow_zn(U1, SA, v);
    element_pow_zn(U2, g, a);
    element_add(U, U1, U2);

    char * U_string = malloc(ELEMENT_STRING_LENGTH);
    char * v_string = malloc(ELEMENT_STRING_LENGTH);

    element_snprint(U_string, ELEMENT_STRING_LENGTH, U);
    element_snprint(v_string, ELEMENT_STRING_LENGTH, v);

//    element_printf("Your U is = %B\n", U);
//    element_printf("Your v is = %B\n", v);

    char ** sig = malloc(sizeof (int));
    sig[0] = U_string;
    sig[1] = v_string;

    printf("Signature of message |%s| is successfully created!\n", message);
    return sig;
}

int Verify(char ** sig, char ** DevicePublicKey, char * message, char * ID){

    // reconstruct elements

    element_t XA, YA, U, v, r;

    element_init_G1(XA, p);
    element_init_G1(YA, p);
    char * XA_string = DevicePublicKey[0];
    char * YA_string = DevicePublicKey[1];
    element_set_str(XA, XA_string, 10);
    element_set_str(YA, YA_string, 10);

    element_init_G1(U, p);
    element_init_Zr(v, p);
    char * U_string = sig[0];
    char * v_string = sig[1];
    element_set_str(U, U_string, 10);
    element_set_str(v, v_string, 10);

    element_init_GT(r, p);

    // Verification Step 1

    element_t result_left, result_right;
    element_init_GT(result_left, p);
    element_init_GT(result_right, p);

    element_pairing(result_left, XA, P0);
    element_pairing(result_right, YA, g);

    if(element_cmp(result_left, result_right)) {printf("Verification failed at S1"); return 1;}

    // Verification Step 2

    element_t result1, result2, result3, QA;
    element_init_GT(result1, p);
    element_init_GT(result2, p);
    element_init_GT(result3, p);
    element_init_G1(QA, p);

    unsigned char * ID_hash = malloc(SHA256_DIGEST_LENGTH+1); // as verifier, one should use other person's ID and locally verify
    memset(ID_hash, 0, SHA256_DIGEST_LENGTH+1);

    SHA256((const unsigned char *) ID, strlen(ID), ID_hash);
    int hashlen = strlen((char *) ID_hash);
    element_from_hash(QA, ID_hash, hashlen); // check if replaceable with SHA256_DIGEST_LENGTH

    element_t negYA;
    element_init_G1(negYA, p);
    element_neg(negYA, YA);

    element_pairing(result1, U, g);
    element_pairing(result2, QA, negYA);
    element_pow_zn(result3, result2, v);

    element_mul(r, result1, result3);

    char * r_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(r_string, ELEMENT_STRING_LENGTH, r);

    unsigned char * hash = malloc(SHA256_DIGEST_LENGTH+1);
    unsigned char * hash1 = malloc(SHA256_DIGEST_LENGTH+1);
    unsigned char * hash2 = malloc(SHA256_DIGEST_LENGTH+1);

    memset(hash, 0, SHA256_DIGEST_LENGTH+1);
    memset(hash1, 0, SHA256_DIGEST_LENGTH+1);
    memset(hash2, 0, SHA256_DIGEST_LENGTH+1);

    SHA256((const unsigned char *) message, strlen(message), hash1);
    SHA256((const unsigned char *) r_string, strlen(r_string), hash2);

//    printf("Your strlen hash1 is = %lu\n", strlen((char *)hash1));
//    printf("Your strlen hash2 is = %lu\n", strlen((char *)hash2));

    unsigned char * prehash = malloc(SHA256_DIGEST_LENGTH*2);
    memset(prehash, 0, SHA256_DIGEST_LENGTH*2);

    strcat((char *)prehash, (char *)hash1);
    strcat((char *)prehash, (char *)hash2);

    SHA256((const unsigned char *) (prehash), strlen((char *)prehash), hash);

    hashlen = strlen((char *) hash);

//    printf("Your strlen of prehash is = %lu\n", strlen((char *)prehash));
//    puts(prehash);

    SHA256((const unsigned char *) (prehash), strlen((char *)prehash), hash);

//    printf("Your strlen of hash is = %lu\n", strlen((char *)hash));
//    puts(hash);


    element_t v_canonical;
    element_init_Zr(v_canonical, p);
    element_from_hash(v_canonical, (const void *)hash, hashlen);

//    element_printf("Your v_canonical is = %B\n", v_canonical);
//    element_printf("Your v is = %B\n", v);

    if(element_cmp(v, v_canonical)) {printf("Verification failed at S2"); return 1;}

    printf("Your request to verify signature of message |%s| is complete, successful!\n", message);
    return 0;
}
// IoT device finish

int main(){

    setup();
    // TODO! Setup with parameter reconstruction

    init_test();

    void * ID = "Peter_Liu"; // ID could be any string

    char ** PartialPrivateKeyParams = ExtractPartialPrivateKey(ID);
    char * QA_string = PartialPrivateKeyParams[0];
    char * DA_string = PartialPrivateKeyParams[1];

    // printf("Your PartialPrivateKey is = %s\n", PartialPrivateKey);

    // puts((char *) PartialPrivateKey[0]);
    // puts((char *) PartialPrivateKey[1]);
    // puts((char *) ID);

    element_t QA;
    element_init_G1(QA, p);
    element_set_str(QA, QA_string, 10); // why is base=10, idk
//    element_printf("Your QA after transmission is = %B\n", QA);

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, DA_string, 10);
//    element_printf("Your DA after transmission is = %B\n", DA);

    VerifyPartialPrivateKeyIsCorrect(PartialPrivateKeyParams);

    element_t xA;
    element_init_Zr(xA, p);
    char * xA_string;

    xA_string = SetSecretValue();

    element_set_str(xA, xA_string, 10);
//    element_printf("Your xA after transmission is = %B\n", xA);

    element_t SA;
    element_init_G1(SA, p);
    char * SA_string;

    SA_string = SetPrivateKey(xA_string, DA_string);
    element_set_str(SA, SA_string, 10);
//    element_printf("Your SA after transmission is = %B\n", SA);

    char ** DevicePublicKey = SetPublicKey(xA_string);

    element_t XA, YA;
    element_init_G1(XA, p);
    element_init_G1(YA, p);

    char * XA_string = DevicePublicKey[0];
    char * YA_string = DevicePublicKey[1];

    element_set_str(XA, XA_string, 10);
    element_set_str(YA, YA_string, 10);

//    element_printf("Your XA after transmission is = %B\n", XA);
//    element_printf("Your YA after transmission is = %B\n", YA);

    char * message = "Never gonna give you up";

//    int elementG1_string_size = sizeof XA_string;
//    int elementZr_string_size = sizeof xA_string;
//
//    printf("Your element G1_string_size is = %d\n", elementG1_string_size);
//    printf("Your elementZr_string_size is = %d\n", elementZr_string_size);
//

    char ** sig = Sign(message, SA_string);

    int result = Verify(sig, DevicePublicKey, message, (void *) ID);
    printf("Your signature result is = %d, where 0 is successful!\n", result);

    // FreeElements();

    return 0;
}