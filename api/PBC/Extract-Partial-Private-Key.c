//
// Created by PL on 2022/8/2.
//
#include "../../pbc/include/pbc.h"
#include "string.h"
#include "setup.h"
#include <openssl/sha.h>

// KGC part starts
char ** ExtractPartialPrivateKey(pairing_t p, void * ID){
    unsigned char * hash = malloc(SHA256_DIGEST_LENGTH+1); // bytes, 32. MUST +1! otherwise \0 is lost and strlen() becomes unreliable.
    SHA256(ID, strlen(ID), hash);

//    int hashlen = strlen((char *) hash); // 32
//    printf("Your hash in EPPK is = %s\n", hash);
//    printf("Your hashlen in EPPK is = %d\n", hashlen);

    element_t QA;
    element_init_G1(QA, p);
    element_from_hash(QA, hash, SHA256_DIGEST_LENGTH); // check if replaceable with SHA256_DIGEST_LENGTH

    element_t DA;
    element_init_G1(DA, p);
    element_pow_zn(DA, QA, masterPrivateKey);

    element_printf("Your partial private key QA generated in KGC is = %B\n", QA);
    element_printf("Your partial private key DA generated in KGC is = %B\n", DA);

    free(hash);

    char * QA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(QA_string, ELEMENT_STRING_LENGTH, QA);

    char * DA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(DA_string, ELEMENT_STRING_LENGTH, DA);

//    puts(QA_string);
//    puts(DA_string);

    char ** output = malloc(sizeof(QA_string)+sizeof(DA_string));
    output[0] = QA_string;
    output[1] = DA_string;
    return output;
}

// char * marshall_all_params_to_buffer(params param){
//     // Params are generated by KGC only; it should be exported after initialization.
//     // TODO
//     // Send RESTFUL HTTP call using CoreHTTP SDK
//     // unmarshall and construct pairing using param-ed setup()
//     return;
// }
//
//
// char * marshall_all_buffer_to_params(char *){
//     return ;
// }

// KGC part finish

// IoT device part start

int VerifyPartialPrivateKeyIsCorrect(pairing_t p, char ** PartialPrivateKeyParams){

    element_t QA;
    element_init_G1(QA, p);
    element_set_str(QA, PartialPrivateKeyParams[0], 10); // decimal output

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, PartialPrivateKeyParams[1], 10);

//    element_printf("Your QA after transmission in Verify is = %B\n", QA);
//    element_printf("Your DA after transmission in Verify is = %B\n", DA);

    element_t result1, result2;
    element_init_GT(result1, p);
    element_init_GT(result2, p);

    element_pairing(result1, DA, g);
    element_pairing(result2, QA, P0);

    int result = element_cmp(result1, result2);
    printf("Your partial private key verification result is = %d, 0 if Partial Secret is correctly generated\n", result);

    return 0;
}

char * SetSecretValue(pairing_t p){

    // Device creates a pure random secret (depends on nothing) for himself
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t xA;
    element_init_Zr(xA, p);
    element_random(xA);

    char * xA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(xA_string, ELEMENT_STRING_LENGTH, xA);

    element_printf("Your local secret xA first created as = %B\n", xA);
//    puts(xA_string);

    return xA_string;
}

char * SetPrivateKey(pairing_t p, char * xA_string, char * DA_string){

    // Device creates his full private key, from his local secret xA and KGC partial private key DA
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t SA;
    element_init_G1(SA, p);

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, DA_string, 10);

    element_t xA;
    element_init_Zr(xA, p);
    element_set_str(xA, xA_string, 10);

//    element_printf("Your DA after transmission in SetPrivateKey() is = %B\n", DA);
//    element_printf("Your xA after transmission in SetPrivateKey() is = %B\n", xA);

    element_pow_zn(SA, DA, xA);

    char * SA_string = malloc(ELEMENT_STRING_LENGTH);
    element_snprint(SA_string, ELEMENT_STRING_LENGTH, SA);

    element_printf("Your device full private key is created locally as SA = %B\n", SA);
//    puts(SA_string);

    return SA_string;
}

char ** SetPublicKey(pairing_t p, char * xA_string){

    // Device creates his full public key from his local secret xA
    // In TEE settings, this part should be executed in TEE secure zone.

    element_t xA;
    element_init_Zr(xA, p);
    element_set_str(xA, xA_string, 10);

    char ** DevicePublicKey = malloc(ELEMENT_STRING_LENGTH*2);
    char * XA_string = malloc(ELEMENT_STRING_LENGTH);
    char * YA_string = malloc(ELEMENT_STRING_LENGTH);

    element_t XA, YA;
    element_init_G1(XA, p);
    element_init_G1(YA, p);

    element_pow_zn(XA, g, xA);
    element_pow_zn(YA, P0, xA);

    element_snprint(XA_string, ELEMENT_STRING_LENGTH, XA);
    element_snprint(YA_string, ELEMENT_STRING_LENGTH, YA);

    DevicePublicKey[0] = XA_string;
    DevicePublicKey[1] = YA_string;

//    element_printf("Your XA before transmission is = %B\n", XA);
//    element_printf("Your YA before transmission is = %B\n", YA);
//    puts(XA_string);
//    puts(YA_string);

    element_printf("Your device full public key is created locally as XA = %B\n", XA);
    element_printf("Your device full public key is created locally as YA = %B\n", YA);

    return DevicePublicKey;
}

void RegisterPublicKey(char * PA){
    // marshall to JSON format and send via CoreHTTP of AWS
    return;
}

char * RetrieveParams(void){
    char * s;
    // Params are generated by KGC only; device can only retrieve them.
    // Send RESTFUL HTTP call using CoreHTTP SDK
    // unmarshall and construct pairing using param-ed setup()
    return s;
}

char ** Sign(pairing_t p, char * message, char * SA_string){

    printf("Your message to sign is = |%s|\n", message);
    element_t SA;
    element_init_G1(SA, p);
    element_set_str(SA, SA_string, 10);

    element_t a, aP, r, v;
    element_init_Zr(a, p);
    element_init_GT(r, p);
    element_init_G1(aP, p);

//    element_printf("Your SA is = %B\n", SA);
//    element_printf("Your a is = %B\n", a);

    element_random(a);
    element_pow_zn(aP, g, a);
    element_pairing(r, aP, g);

//    element_printf("Your aP is = %B\n", aP);
//    element_printf("Your r is = %B\n", r);

    char * hash = string_times_G2_to_Zr_SHA256((const unsigned char *) message, r);

    element_init_Zr(v, p);
    element_from_hash(v, (const void *)hash, SHA256_DIGEST_LENGTH);

    element_t U, U1, U2;
    element_init_G1(U, p);
    element_init_G1(U1, p);
    element_init_G1(U2, p);

    element_pow_zn(U1, SA, v);
    element_pow_zn(U2, g, a);
    element_add(U, U1, U2);

    char * U_string = malloc(ELEMENT_STRING_LENGTH);
    char * v_string = malloc(ELEMENT_STRING_LENGTH);

    element_snprint(U_string, ELEMENT_STRING_LENGTH, U);
    element_snprint(v_string, ELEMENT_STRING_LENGTH, v);

//    element_printf("Your U is = %B\n", U);
//    element_printf("Your v is = %B\n", v);

    char ** sig = malloc(sizeof (int));
    sig[0] = U_string;
    sig[1] = v_string;

    printf("Signature of message |%s| is successfully created!\n", message);
    return sig;
}

int Verify(pairing_t p, char ** sig, char ** DevicePublicKey, char * message, char * ID){

    // reconstruct elements

    element_t XA, YA, U, v, r;

    element_init_G1(XA, p);
    element_init_G1(YA, p);
    char * XA_string = DevicePublicKey[0];
    char * YA_string = DevicePublicKey[1];
    element_set_str(XA, XA_string, 10);
    element_set_str(YA, YA_string, 10);

    element_init_G1(U, p);
    element_init_Zr(v, p);
    char * U_string = sig[0];
    char * v_string = sig[1];
    element_set_str(U, U_string, 10);
    element_set_str(v, v_string, 10);

    element_init_GT(r, p);

    // Verification Step 1

    element_t result_left, result_right;
    element_init_GT(result_left, p);
    element_init_GT(result_right, p);

    element_pairing(result_left, XA, P0);
    element_pairing(result_right, YA, g);

    if(element_cmp(result_left, result_right)) {printf("Verification failed at S1"); return 1;}

    // Verification Step 2

    element_t result1, result2, result3, QA;
    element_init_GT(result1, p);
    element_init_GT(result2, p);
    element_init_GT(result3, p);
    element_init_G1(QA, p);

    char * ID_hash = simpleSHA256((const unsigned char *) ID, strlen(ID));

    element_from_hash(QA, ID_hash, SHA256_DIGEST_LENGTH);

    element_t negYA;
    element_init_G1(negYA, p);
    element_neg(negYA, YA);

    element_pairing(result1, U, g);
    element_pairing(result2, QA, negYA);
    element_pow_zn(result3, result2, v);

    element_mul(r, result1, result3);

    char * hash = string_times_G2_to_Zr_SHA256(message, r);

    element_t v_canonical;
    element_init_Zr(v_canonical, p);
    element_from_hash(v_canonical, (const void *)hash, SHA256_DIGEST_LENGTH);

//    element_printf("Your v_canonical is = %B\n", v_canonical);
//    element_printf("Your v is = %B\n", v);

    if(element_cmp(v, v_canonical)) {printf("Verification failed at S2"); return 1;}

    printf("Your request to verify signature of message |%s| is complete, successful!\n", message);
    return 0;
}
// IoT device finish

int main(){

    setup();

//    pairing_clear(p);

//    par_param_buffer = extract_pairing_param_buffer_from_file();
//    setup_with_param_buffer(p, par_param_buffer, PARAM_BUFFER_LENGTH_TYPE_A);

    init_test();

    void * ID = "Peter_Liu"; // ID could be any string

    char ** PartialPrivateKeyParams = ExtractPartialPrivateKey(p, ID);
    char * QA_string = PartialPrivateKeyParams[0];
    char * DA_string = PartialPrivateKeyParams[1];

    // printf("Your PartialPrivateKey is = %s\n", PartialPrivateKey);

    // puts((char *) PartialPrivateKey[0]);
    // puts((char *) PartialPrivateKey[1]);
    // puts((char *) ID);

    element_t QA;
    element_init_G1(QA, p);
    element_set_str(QA, QA_string, 10); // why is base=10, idk
//    element_printf("Your QA after transmission is = %B\n", QA);

    element_t DA;
    element_init_G1(DA, p);
    element_set_str(DA, DA_string, 10);
//    element_printf("Your DA after transmission is = %B\n", DA);

    VerifyPartialPrivateKeyIsCorrect(p, PartialPrivateKeyParams);

    element_t xA;
    element_init_Zr(xA, p);
    char * xA_string;

    xA_string = SetSecretValue(p);

    element_set_str(xA, xA_string, 10);
//    element_printf("Your xA after transmission is = %B\n", xA);

    element_t SA;
    element_init_G1(SA, p);
    char * SA_string;

    SA_string = SetPrivateKey(p, xA_string, DA_string);
    element_set_str(SA, SA_string, 10);
//    element_printf("Your SA after transmission is = %B\n", SA);

    char ** DevicePublicKey = SetPublicKey(p, xA_string);

    element_t XA, YA;
    element_init_G1(XA, p);
    element_init_G1(YA, p);

    printf("Your element_length_in_bytes(XA) is = %d\n", element_length_in_bytes(XA));
    printf("Your element_length_in_bytes(YA) is = %d\n", element_length_in_bytes(YA));

    char * XA_string = DevicePublicKey[0];
    char * YA_string = DevicePublicKey[1];

    element_set_str(XA, XA_string, 10);
    element_set_str(YA, YA_string, 10);

    printf("Your strlen(XA_string) is = %lu\n", strlen(XA_string));
    printf("Your strlen(YA_string) is = %lu\n", strlen(YA_string));

//    element_printf("Your XA after transmission is = %B\n", XA);
//    element_printf("Your YA after transmission is = %B\n", YA);

    char * message = "Never gonna give you up";

//    int elementG1_string_size = sizeof XA_string;
//    int elementZr_string_size = sizeof xA_string;
//
//    printf("Your element G1_string_size is = %d\n", elementG1_string_size);
//    printf("Your elementZr_string_size is = %d\n", elementZr_string_size);
//

    char ** sig = Sign(p, message, SA_string);

    int result = Verify(p, sig, DevicePublicKey, message, (void *) ID);
    printf("Your signature result is = %d, where 0 is successful!\n", result);

    // FreeElements(pairing_t p);

    return 0;
}

//unsigned char * compress_signature_before_transmission(element_t sig){
//    unsigned char * a;
//    return a;
//}